<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>W-MINDオセロ</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            
            /* 六芒星をイメージした背景パターン */
            background-color: #0d1a2b; /* 暗い青系の背景色 */
            background-image: 
                repeating-linear-gradient(45deg, rgba(0, 188, 212, 0.05) 0, rgba(0, 188, 212, 0.05) 1px, transparent 1px, transparent 10px),
                repeating-linear-gradient(-45deg, rgba(0, 188, 212, 0.05) 0, rgba(0, 188, 212, 0.05) 1px, transparent 1px, transparent 10px);
            background-size: 20px 20px; /* パターンの密度調整 */
            background-attachment: fixed;
            
            color: #e0f7fa; /* 明るい水色系の文字色 */
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.7);
        }

        h1 {
            color: #80deea; /* 明るいシアン系のタイトル色 */
            margin-bottom: 20px;
            font-size: 2.8em;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.6);
        }

        .game-info {
            font-size: 1.3em;
            margin-bottom: 20px;
            background-color: rgba(0, 0, 0, 0.7); /* 半透明の暗い背景 */
            padding: 12px 25px;
            border-radius: 10px;
            display: flex;
            gap: 25px;
            align-items: center;
            border: 1px solid #00bcd4; /* 細いボーダー */
            box-shadow: 0 4px 15px rgba(0, 220, 255, 0.4); /* 光る影 */
        }
        .stone-count {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: bold;
        }
        .stone-count .black-stone-icon, .stone-count .white-stone-icon {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.4);
            box-shadow: 0 0 5px rgba(255,255,255,0.3);
        }
        .stone-count .black-stone-icon {
            background-color: #333;
        }
        .stone-count .white-stone-icon {
            background-color: #eee;
        }

        /* ゲームタイマーのスタイル */
        .game-timer {
            font-size: 1.1em;
            font-weight: bold;
            color: #00bcd4; /* シアン系の色 */
            min-width: 80px; /* 表示が揺れないように幅を固定 */
            text-align: right;
        }

        .board-container {
            border: 6px solid #1a237e; /* 濃い青の枠 */
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.6), 0 0 20px rgba(0, 220, 255, 0.5); /* 光る影 */
            background-color: #004d40; /* 深い緑系のオセロ盤色 */
            padding: 12px;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(6, 65px); /* 6x6マス */
            grid-template-rows: repeat(6, 65px);
            border: 1px solid #00251a; /* マス間の暗い線 */
            box-sizing: content-box;
        }

        .cell {
            width: 65px;
            height: 65px;
            border: 1px solid #003328; /* マスとマスの間の線 */
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            box-sizing: border-box;
            transition: background-color 0.2s ease;
        }

        .stone {
            width: 55px;
            height: 55px;
            border-radius: 50%;
            border: 3px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 0 8px rgba(0, 0, 0, 0.5), 0 4px 8px rgba(0, 0, 0, 0.7);
            transition: transform 0.1s ease-out, background-color 0.3s ease;
            display: flex; /* 文字を中央に配置するためにflexboxを使用 */
            justify-content: center;
            align-items: center;
            font-size: 1.8em; /* 文字の大きさ */
            font-weight: bold;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.5);
        }

        .stone.black {
            background-color: #1a1a1a; /* 濃い黒 */
            border-color: #444;
            color: #333; /* 黒石の文字色を黒に固定 */
        }

        .stone.white {
            background-color: #f0f0f0; /* 明るい白 */
            border-color: #ccc;
            color: #333; /* 白石の文字色を黒に固定 */
        }
        
        /* 置ける場所のハイライト */
        .cell.highlight {
            background-color: rgba(0, 255, 255, 0.2); /* シアン系の光るハイライト */
        }
        .cell.highlight:hover {
            background-color: rgba(0, 255, 255, 0.4); /* ホバーで少し濃く */
        }
        .cell.highlight:active {
            transform: scale(0.95); /* クリック時に少し縮む */
        }


        /* メッセージ表示エリア */
        .message {
            margin-top: 25px;
            font-size: 1.3em;
            font-weight: bold;
            color: #ffeb3b; /* 明るい黄色 */
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 8px;
            border: 1px solid #ffc107;
            box-shadow: 0 0 10px rgba(255, 235, 59, 0.5);
            text-align: center; /* 中央寄せ */
        }

        /* 勝敗結果の最終表示スタイル */
        .message.final-result {
            font-size: 4em; /* 大きく表示 */
            color: #ffeb3b; /* 黄色 */
            background-color: rgba(0, 0, 0, 0.8);
            padding: 30px 50px;
            border-radius: 15px;
            border: 3px solid #ffeb3b;
            box-shadow: 0 0 30px rgba(255, 235, 59, 0.8);
            text-shadow: 4px 4px 8px rgba(0, 0, 0, 0.8);
            opacity: 0; /* 初期状態は透明 */
            transform: scale(0.5); /* 初期状態は小さく */
            animation: fadeInScaleUp 1s forwards cubic-bezier(0.25, 0.46, 0.45, 0.94); /* アニメーション適用 */
        }

        /* アニメーション定義 */
        @keyframes fadeInScaleUp {
            from {
                opacity: 0;
                transform: scale(0.5);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }


        /* リセットボタン */
        .reset-button {
            margin-top: 25px;
            padding: 14px 30px;
            font-size: 1.2em;
            background-color: #e53935; /* 赤色 */
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4);
        }
        .reset-button:hover {
            background-color: #c62828;
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.5);
        }

        /* ノイズオーバーレイ */
        #noiseOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            /* ノイズのSVGデータURI - opacityとbaseFrequencyを調整して強調 */
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%"><filter id="noise"><feTurbulence type="fractalNoise" baseFrequency="0.9" numOctaves="3" stitchTiles="stitch"/></filter><rect width="100%" height="100%" filter="url(#noise)" opacity="0.25"/></svg>');
            background-size: cover;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.1s ease-in-out;
            z-index: 1000;
            pointer-events: none; /* 下の要素のクリックを妨げない */
        }

        #noiseOverlay.active {
            opacity: 1;
            visibility: visible;
            animation: noiseEffect 0.1s steps(2) infinite; /* 高速アニメーションでノイズ感を出す */
        }

        @keyframes noiseEffect {
            0% { background-position: 0 0; }
            100% { background-position: 100% 100%; }
        }

        /* 全画面メッセージ (通常HACKING用) */
        #fullScreenMessage {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 5em;
            font-weight: bold;
            color: #ff00ff; /* 通常ハッキングはマゼンタ */
            text-shadow: 0 0 15px #ff00ff, 0 0 25px #ff00ff; /* 輝くエフェクト */
            background-color: rgba(0, 0, 0, 0.8);
            padding: 30px 60px;
            border-radius: 20px;
            border: 3px solid #ff00ff;
            z-index: 1001;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out;
            text-align: center;
            line-height: 1.2;
        }

        #fullScreenMessage.show {
            opacity: 1;
            visibility: visible;
        }

        /* 全画面メッセージ (特殊HACKING SP用) */
        #fullScreenMessage.sp {
            color: #ffff00; /* SPハッキングは鮮やかな黄色 */
            text-shadow: 0 0 20px #ffff00, 0 0 40px #ffff00, 0 0 60px rgba(255, 255, 0, 0.7); /* より強く光る */
            border-color: #ffff00;
            background-color: rgba(0, 0, 0, 0.9); /* より濃い背景 */
        }

        /* 全画面メッセージ (幸運イベント用) */
        #fullScreenMessage.lucky {
            color: #00e676; /* 幸運は明るい緑 */
            text-shadow: 0 0 10px #00e676, 0 0 20px #00e676;
            border-color: #00e676;
            background-color: rgba(0, 0, 0, 0.75);
        }

        /* 全画面メッセージ (ジャミングイベント用) */
        #fullScreenMessage.jamming {
            color: #ff6f00; /* ジャミングはオレンジ */
            text-shadow: 0 0 10px #ff6f00, 0 0 20px #ff6f00;
            border-color: #ff6f00;
            background-color: rgba(0, 0, 0, 0.8);
        }

        /* 全画面メッセージ (オーバーロードイベント用) */
        #fullScreenMessage.overload {
            color: #00b0ff; /* オーバーロードは青 */
            text-shadow: 0 0 10px #00b0ff, 0 0 20px #00b0ff;
            border-color: #00b0ff;
            background-color: rgba(0, 0, 0, 0.8);
        }
        
        /* 全画面メッセージ (しあらーの一服 SP用) */
        #fullScreenMessage.shirara-sp {
            color: #c7c7c7; /* 少し暗めの白 */
            text-shadow: 0 0 10px #c7c7c7, 0 0 20px #c7c7c7;
            border-color: #c7c7c7;
            background-color: rgba(0, 0, 0, 0.85);
        }


        /* 暗転オーバーレイ */
        #darknessOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0); /* 初期は透明 */
            z-index: 999; /* 他のオーバーレイより下 */
            opacity: 0;
            visibility: hidden;
            transition: opacity 2s ease-out; /* 徐々に暗転 */
            pointer-events: none;
        }

        #darknessOverlay.active {
            opacity: 1;
            visibility: visible;
            background-color: rgba(0, 0, 0, 0.95); /* ほぼ真っ暗 */
        }

        /* 光が降り注ぐアニメーションのオーバーレイ */
        #lightRayOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            pointer-events: none;
            z-index: 998; /* 他のイベントより少し低いz-index */
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s ease-out;
        }

        #lightRayOverlay.active {
            opacity: 1;
            visibility: visible;
        }

        .light-ray {
            position: absolute;
            background: linear-gradient(to bottom, rgba(255, 255, 200, 0), rgba(255, 255, 200, 0.6), rgba(255, 255, 200, 0));
            width: 3px; /* 光線の太さ */
            height: 100vh;
            transform-origin: top center;
            opacity: 0;
            animation: lightRayDrop 2s ease-in-out forwards;
        }

        @keyframes lightRayDrop {
            0% { transform: translateY(-100%) rotateZ(var(--ray-rotate, 0deg)); opacity: 0; }
            50% { opacity: 1; }
            100% { transform: translateY(0%) rotateZ(var(--ray-rotate, 0deg)); opacity: 0; }
        }

        /* 紙吹雪のコンテナ */
        .confetti-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* クリックを妨げない */
            overflow: hidden; /* 画面外の紙吹雪を隠す */
            z-index: 9999; /* 最前面に表示 */
        }

        /* 紙吹雪のアニメーション */
        @keyframes confettiFall {
            0% { transform: translateY(-100vh) rotateZ(0deg); opacity: 0; }
            10% { opacity: 1; }
            100% { transform: translateY(100vh) rotateZ(720deg); opacity: 0; }
        }

        /* 紙吹雪のスタイル */
        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: #f00; /* デフォルトの色 */
            border-radius: 50%;
            animation: confettiFall 5s linear infinite; /* アニメーション適用 */
            opacity: 0;
        }

        /* 紙吹雪のバリエーション */
        .confetti:nth-child(even) { background-color: #0f0; border-radius: 0%; animation-duration: 4.5s; }
        .confetti:nth-child(3n) { background-color: #00f; border-radius: 20%; animation-duration: 5.5s; }
        .confetti:nth-child(4n) { background-color: #ff0; border-radius: 10%; animation-duration: 4s; }
        .confetti:nth-child(5n) { background-color: #f0f; border-radius: 30%; animation-duration: 6s; }
        .confetti:nth-child(7n) { background-color: #0ff; animation-duration: 5.2s; }

        /* 石の点滅アニメーション (アゼミチの幸運用およびオーバーロード用) */
        @keyframes stoneBlink {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.7; border-color: yellow; box-shadow: 0 0 15px yellow; }
        }

        .stone.blink {
            animation: stoneBlink 0.4s ease-in-out infinite; /* 2秒間で約5回点滅 */
        }

        /* 画面揺れアニメーション */
        @keyframes screenShake {
            0%, 100% { transform: translate(0, 0); }
            10%, 30%, 50%, 70%, 90% { transform: translate(-5px, -5px); }
            20%, 40%, 60%, 80% { transform: translate(5px, 5px); }
        }

        body.shake-active {
            animation: screenShake 0.2s linear infinite; /* 短い間隔で高速に揺らす */
        }

        /* 蒸気アニメーション */
        #steamOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 1000; /* 他のオーバーレイより上 */
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s ease-out;
            background: radial-gradient(circle at bottom center, rgba(255, 255, 255, 0.4) 0%, rgba(255, 255, 255, 0) 70%); /* 下から白くぼんやり */
            transform: scaleY(0); /* 最初は圧縮 */
            transform-origin: bottom;
        }

        #steamOverlay.active {
            opacity: 1;
            visibility: visible;
            animation: steamRise 2s forwards ease-out;
        }

        @keyframes steamRise {
            0% { transform: scaleY(0); opacity: 0; }
            50% { transform: scaleY(1); opacity: 1; }
            100% { transform: scaleY(1); opacity: 0; } /* 最後は消える */
        }

        /* タバコの煙アニメーション */
        #smokeOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s ease-out;
            background: radial-gradient(circle at 80% 90%, rgba(100, 100, 100, 0.1) 0%, rgba(0, 0, 0, 0) 50%); /* 下から右上に煙が広がるイメージ */
            animation: smokeDrift 6s infinite alternate ease-in-out; /* 左右にたゆたうアニメーション */
            background-size: 200% 200%; /* グラデーションのサイズを大きくして動きに変化を持たせる */
            background-position: 50% 50%; /* 中央から開始 */
        }

        #smokeOverlay.active {
            opacity: 1;
            visibility: visible;
            animation: smokeDrift 6s infinite alternate ease-in-out, fadeInOut 5s forwards; /* フェードイン・アウトとたゆたう動き */
        }

        @keyframes smokeDrift {
            0% { background-position: 0% 0%; }
            100% { background-position: 100% 100%; }
        }

        @keyframes fadeInOut {
            0% { opacity: 0; }
            20% { opacity: 1; }
            80% { opacity: 1; }
            100% { opacity: 0; }
        }

    </style>
</head>
<body>
    <h1>W-MINDオセロ</h1>
    <div class="game-info">
        現在の手番: <span id="turnInfo"></span>
        <div class="stone-count">
            <div class="black-stone-icon"></div> <span id="blackCount"></span>
            <div class="white-stone-icon"></div> <span id="whiteCount"></span>
        </div>
        <div class="game-timer">時間: <span id="timerDisplay">00:00</span></div>
    </div>
    <div class="board-container">
        <div class="board" id="othelloBoard">
            </div>
    </div>
    <div id="message" class="message"></div>
    <button id="resetButton" class="reset-button">リセット</button>

    <div id="noiseOverlay"></div>
    <div id="fullScreenMessage"></div>
    <div id="darknessOverlay"></div>
    <div id="lightRayOverlay"></div>
    <div id="steamOverlay"></div>
    <div id="smokeOverlay"></div>
    <div id="confettiContainer" class="confetti-container"></div>

    <script>
        const boardElement = document.getElementById('othelloBoard');
        const turnInfoElement = document.getElementById('turnInfo');
        const messageElement = document.getElementById('message');
        const blackCountElement = document.getElementById('blackCount');
        const whiteCountElement = document.getElementById('whiteCount');
        const resetButton = document.getElementById('resetButton');
        const timerDisplayElement = document.getElementById('timerDisplay');
        const noiseOverlayElement = document.getElementById('noiseOverlay');
        const fullScreenMessageElement = document.getElementById('fullScreenMessage');
        const darknessOverlayElement = document.getElementById('darknessOverlay'); 
        const lightRayOverlayElement = document.getElementById('lightRayOverlay');
        const steamOverlayElement = document.getElementById('steamOverlay'); 
        const smokeOverlayElement = document.getElementById('smokeOverlay'); 
        const confettiContainer = document.getElementById('confettiContainer');

        const BOARD_SIZE = 6;
        const EMPTY = 0;
        const BLACK = 1;
        const WHITE = 2; // CPU

        const PLAYER_NAME = 'W-MIND';
        const CPU_NAME = 'BrainVerse';

        let board = [];
        let currentPlayer = BLACK;
        let gameOver = false;
        let passCount = 0;

        let startTime;
        let timerInterval;
        let gameStarted = false;

        let isSpecialEventActive = false; // 特殊イベントが進行中かどうかのフラグ
        let cpuFlipBlocked = false; // NICKELのジャミング効果用フラグ
        let eventJustOccurred = false; // イベントが直前に発生したかどうかのフラグ

        // ゲームの初期化
        function initializeGame() {
            board = Array(BOARD_SIZE).fill(0).map(() => Array(BOARD_SIZE).fill(EMPTY));
            
            // 初期配置 (中央4マス) - 6x6の場合
            const center = BOARD_SIZE / 2;
            board[center - 1][center - 1] = WHITE;
            board[center - 1][center]     = BLACK;
            board[center][center - 1]     = BLACK;
            board[center][center]         = WHITE;

            currentPlayer = BLACK; // 黒 (W-MIND) から開始
            gameOver = false;
            passCount = 0;
            
            messageElement.textContent = 'ゲーム開始！';
            messageElement.classList.remove('final-result');
            messageElement.style.color = '#ffeb3b'; 
            messageElement.style.borderColor = '#ffc107';
            messageElement.style.boxShadow = '0 0 10px rgba(255, 235, 59, 0.5)';

            // タイマーのリセット
            startTime = null;
            clearInterval(timerInterval);
            timerDisplayElement.textContent = '00:00';
            gameStarted = false;

            // イベント関連のリセット
            isSpecialEventActive = false;
            cpuFlipBlocked = false; 
            eventJustOccurred = false; // イベント発生フラグもリセット

            noiseOverlayElement.classList.remove('active');
            fullScreenMessageElement.classList.remove('show', 'sp', 'lucky', 'jamming', 'overload', 'shirara-sp'); 
            fullScreenMessageElement.textContent = '';
            darknessOverlayElement.classList.remove('active');
            lightRayOverlayElement.classList.remove('active');
            lightRayOverlayElement.innerHTML = '';
            steamOverlayElement.classList.remove('active'); 
            smokeOverlayElement.classList.remove('active'); 
            document.body.classList.remove('shake-active'); 
            hideConfetti();

            renderBoard();
            updateGameInfo();
            highlightValidMoves();
        }

        // 盤面の描画
        function renderBoard() {
            boardElement.innerHTML = ''; // 一度クリア
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    
                    if (board[r][c] === BLACK) {
                        const stone = document.createElement('div');
                        stone.classList.add('stone', 'black');
                        stone.textContent = '陰';
                        // 文字色はCSSで固定されているため、ここでの追加クラスは不要
                        cell.appendChild(stone);
                    } else if (board[r][c] === WHITE) {
                        const stone = document.createElement('div');
                        stone.classList.add('stone', 'white');
                        stone.textContent = '陽';
                        // 文字色はCSSで固定されているため、ここでの追加クラスは不要
                        cell.appendChild(stone);
                    }

                    // ゲームが終了していない、かつ、現在のプレイヤーが人間（BLACK）の場合のみクリックイベントを設定
                    // CPUの手番中や特殊イベント中はクリックイベントを無効にする
                    if (!gameOver && currentPlayer === BLACK && !isSpecialEventActive) {
                        cell.addEventListener('click', handleCellClick);
                    } else {
                        cell.removeEventListener('click', handleCellClick); 
                    }
                    boardElement.appendChild(cell);
                }
            }
        }

        // ゲーム情報 (手番、石の数) の更新
        function updateGameInfo() {
            turnInfoElement.textContent = (currentPlayer === BLACK) ? `${PLAYER_NAME} (あなた)` : `${CPU_NAME} (CPU)`;
            
            let blackStones = 0;
            let whiteStones = 0;
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (board[r][c] === BLACK) {
                        blackStones++;
                    } else if (board[r][c] === WHITE) {
                        whiteStones++;
                    }
                }
            }
            blackCountElement.textContent = blackStones;
            whiteCountElement.textContent = whiteStones;
        }

        // 置ける場所のハイライト
        function highlightValidMoves() {
            document.querySelectorAll('.cell').forEach(cell => cell.classList.remove('highlight'));

            // ゲーム終了時、CPU手番中、イベント中はハイライトしない
            if (gameOver || currentPlayer === WHITE || isSpecialEventActive) return; 

            const validMoves = getValidMoves(currentPlayer); 
            validMoves.forEach(move => {
                const cell = boardElement.querySelector(`[data-row='${move.row}'][data-col='${move.col}']`);
                if (cell) {
                    cell.classList.add('highlight');
                }
            });
        }

        // マスがクリックされたときの処理 (プレイヤーの手番)
        function handleCellClick(event) {
            // ゲームが終了している場合、またはCPUの手番である場合、イベント中の場合は処理しない
            if (gameOver || currentPlayer === WHITE || isSpecialEventActive) return; 

            const row = parseInt(event.currentTarget.dataset.row);
            const col = parseInt(event.currentTarget.dataset.col);

            const flips = getFlips(row, col, currentPlayer);

            if (board[row][col] !== EMPTY || flips.length === 0) {
                messageElement.textContent = 'そこには置けません！';
                return;
            }

            // 最初の石が置かれたらタイマーを開始
            if (!gameStarted) {
                startTime = Date.now();
                timerInterval = setInterval(updateTimerDisplay, 1000); // 1秒ごとに更新
                gameStarted = true;
            }

            placeStoneAndFlip(row, col, currentPlayer, flips);
            // プレイヤーが石を置いた後、手番を切り替え
            switchPlayer(); 
        }

        // 石を置いてひっくり返す共通処理
        function placeStoneAndFlip(row, col, player, flips) {
            board[row][col] = player;
            flips.forEach(pos => {
                board[pos.row][pos.col] = player;
            });
            passCount = 0; // 石を置いたのでパス回数をリセット
            renderBoard(); // 石がひっくり返った状態を即座に描画
        }

        // 通常のハッキングシーケンスを発動する関数 (5%確率)
        function triggerHackingSequence() {
            if (gameOver) return;
            isSpecialEventActive = true; // イベント中フラグを立てる
            eventJustOccurred = true; // イベント発生フラグを立てる

            noiseOverlayElement.classList.add('active');
            fullScreenMessageElement.classList.remove('sp', 'lucky', 'jamming', 'overload', 'shirara-sp'); 
            fullScreenMessageElement.textContent = '暗号太郎のHACKING';
            fullScreenMessageElement.classList.add('show');

            // 2秒後に「HACKING」メッセージを消し、「相手は1ターン動けない」を表示
            setTimeout(() => {
                fullScreenMessageElement.classList.remove('show');
                fullScreenMessageElement.textContent = `${CPU_NAME}のターンはスキップされました！`; 
                fullScreenMessageElement.classList.add('show');
                passCount++; // CPUのターンがパスされたのでパス数をインクリメント

                // さらに2秒後にメッセージを消し、ノイズを解除して、次のターンに進む
                setTimeout(() => {
                    fullScreenMessageElement.classList.remove('show');
                    noiseOverlayElement.classList.remove('active');
                    fullScreenMessageElement.textContent = ''; 
                    isSpecialEventActive = false; // イベント終了
                    // HACKINGイベントはCPUのターンをスキップし、プレイヤーのターンに戻す
                    // currentPlayerは既にBLACK（プレイヤー）なのでそのまま進行
                    updateGameInfo(); 
                    checkGameStatus();
                    if (!gameOver) {
                        messageElement.textContent = PLAYER_NAME + 'の手番です。';
                        renderBoard();
                        highlightValidMoves();
                        const playerValidMoves = getValidMoves(BLACK);
                        if (playerValidMoves.length === 0) {
                            messageElement.textContent = PLAYER_NAME + 'は置ける場所がないためパス！';
                            passCount++;
                            // プレイヤーがパスしたら、強制的にCPUターンに切り替え
                            currentPlayer = WHITE;
                            setTimeout(switchPlayer, 500);
                        }
                    }
                }, 2000); 
            }, 2000); 
        }

        // 特殊ハッキング「HACKING SP」シーケンスを発動する関数 (1%確率)
        function triggerHackingSPSequence() {
            if (gameOver) return;
            isSpecialEventActive = true; // イベント中フラグを立てる
            eventJustOccurred = true; // イベント発生フラグを立てる

            darknessOverlayElement.classList.add('active'); 
            
            // 暗転アニメーション完了を待ってからメッセージを表示
            setTimeout(() => {
                fullScreenMessageElement.classList.add('sp'); 
                fullScreenMessageElement.classList.remove('lucky', 'jamming', 'overload', 'shirara-sp'); 
                fullScreenMessageElement.textContent = '暗号太郎のHACKING SP';
                fullScreenMessageElement.classList.add('show');

                // 3秒後にメッセージを消し、盤面を全て黒にする
                setTimeout(() => {
                    fullScreenMessageElement.classList.remove('show', 'sp'); 
                    fullScreenMessageElement.textContent = ''; 
                    darknessOverlayElement.classList.remove('active'); 

                    // 盤面を全て黒石にする
                    for(let r = 0; r < BOARD_SIZE; r++) {
                        for(let c = 0; c < BOARD_SIZE; c++) {
                            board[r][c] = BLACK;
                        }
                    }
                    renderBoard(); 
                    updateGameInfo(); 

                    isSpecialEventActive = false; // イベント終了

                    // 2秒後に結果画面を表示
                    setTimeout(() => {
                        endGame(true); // プレイヤー勝利でゲーム終了
                    }, 2000); 
                    
                }, 3000); 
            }, 2000); 
        }

        // 光が降り注ぐ「アゼミチの幸運」シーケンスを発動する関数 (5%確率)
        function triggerAzemichiLuckySequence() {
            if (gameOver) return;
            isSpecialEventActive = true; // イベント中フラグを立てる
            eventJustOccurred = true; // イベント発生フラグを立てる

            lightRayOverlayElement.classList.add('active');
            // 光線を生成
            for (let i = 0; i < 20; i++) { 
                const ray = document.createElement('div');
                ray.classList.add('light-ray');
                ray.style.left = `${Math.random() * 100}vw`; 
                ray.style.animationDelay = `${Math.random() * 1}s`; 
                ray.style.setProperty('--ray-rotate', `${(Math.random() - 0.5) * 40}deg`); 
                lightRayOverlayElement.appendChild(ray);
            }

            fullScreenMessageElement.classList.remove('sp', 'jamming', 'overload', 'shirara-sp'); 
            fullScreenMessageElement.classList.add('lucky'); 
            fullScreenMessageElement.textContent = 'アゼミチの幸運';
            fullScreenMessageElement.classList.add('show');

            // 2秒後にメッセージを切り替え、効果を適用
            setTimeout(() => {
                fullScreenMessageElement.textContent = 'BVの石をランダムで1つ反転！';

                // 相手の石（WHITE）の中からランダムで1つ選び、プレイヤーの石（BLACK）に反転させる
                const whiteStones = [];
                for (let r = 0; r < BOARD_SIZE; r++) {
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        if (board[r][c] === WHITE) {
                            whiteStones.push({ row: r, col: c });
                        }
                    }
                }

                if (whiteStones.length > 0) {
                    const randomIndex = Math.floor(Math.random() * whiteStones.length);
                    const targetStone = whiteStones[randomIndex];
                    board[targetStone.row][targetStone.col] = BLACK; 
                    renderBoard(); 
                    updateGameInfo(); 

                    // 反転した石に点滅アニメーションを適用
                    const stoneElement = boardElement.querySelector(`[data-row='${targetStone.row}'][data-col='${targetStone.col}'] .stone`);
                    if (stoneElement) {
                        stoneElement.classList.add('blink');
                        setTimeout(() => {
                            stoneElement.classList.remove('blink'); 
                        }, 6000); // 点滅時間を6秒に変更
                    }
                } else {
                    fullScreenMessageElement.textContent += '(反転できる石がありませんでした)';
                }

                // さらに2秒後にメッセージを消し、光線アニメーションを解除して、次のターンに進む
                setTimeout(() => {
                    fullScreenMessageElement.classList.remove('show', 'lucky');
                    fullScreenMessageElement.classList.remove('show', 'lucky'); // 念のため2回削除
                    fullScreenMessageElement.textContent = ''; 
                    lightRayOverlayElement.classList.remove('active');
                    lightRayOverlayElement.innerHTML = ''; 
                    isSpecialEventActive = false; // イベント終了
                    switchPlayer(); // 次のターンへ
                }, 2000); 
            }, 2000); 
        }

        // 画面揺れ「NICKELのジャミング」シーケンスを発動する関数 (5%確率)
        function triggerNickelJammingSequence() {
            if (gameOver) return;
            isSpecialEventActive = true; // イベント中フラグを立てる
            eventJustOccurred = true; // イベント発生フラグを立てる

            document.body.classList.add('shake-active'); // bodyに揺れアニメーションを適用

            fullScreenMessageElement.classList.remove('sp', 'lucky', 'overload', 'shirara-sp'); 
            fullScreenMessageElement.classList.add('jamming'); 
            fullScreenMessageElement.textContent = 'NICKELのジャミング';
            fullScreenMessageElement.classList.add('show');

            // 2秒後にメッセージを切り替え、効果を適用
            setTimeout(() => {
                fullScreenMessageElement.textContent = '次回BVは石を反転できなくなる！';
                cpuFlipBlocked = true; // CPUの石反転を完全にブロックするフラグを立てる

                // さらに2秒後にメッセージを消し、画面揺れを解除して、次のターンに進む
                setTimeout(() => {
                    fullScreenMessageElement.classList.remove('show', 'jamming');
                    fullScreenMessageElement.textContent = ''; 
                    document.body.classList.remove('shake-active'); 
                    isSpecialEventActive = false; // イベント終了
                    switchPlayer(); // 次のターンへ
                }, 2000); 
            }, 2000); 
        }

        // 蒸気発生「ma--kyunのオーバーロード」シーケンスを発動する関数 (5%確率)
        function triggerMaKyunOverloadSequence() {
            if (gameOver) return;
            isSpecialEventActive = true; // イベント中フラグを立てる
            eventJustOccurred = true; // イベント発生フラグを立てる

            steamOverlayElement.classList.add('active'); // 蒸気アニメーションを適用

            fullScreenMessageElement.classList.remove('sp', 'lucky', 'jamming', 'shirara-sp'); 
            fullScreenMessageElement.classList.add('overload'); 
            fullScreenMessageElement.textContent = 'ma--kyunのオーバーロード';
            fullScreenMessageElement.classList.add('show');

            // 2秒後にメッセージを切り替え、効果を適用
            setTimeout(() => {
                // ここでテキストを修正
                fullScreenMessageElement.textContent = 'BVは過負荷で誤処理！石が2つ反転';

                const affectedStones = []; // 点滅させる石を保持する配列
                // 相手の石（WHITE）の中からランダムで2つ選び、プレイヤーの石（BLACK）に反転させる
                const whiteStones = [];
                for (let r = 0; r < BOARD_SIZE; r++) {
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        if (board[r][c] === WHITE) {
                            whiteStones.push({ row: r, col: c });
                        }
                    }
                }

                // 2つ反転させる
                for (let i = 0; i < 2; i++) {
                    if (whiteStones.length > 0) {
                        const randomIndex = Math.floor(Math.random() * whiteStones.length);
                        const targetStone = whiteStones.splice(randomIndex, 1)[0]; 
                        board[targetStone.row][targetStone.col] = BLACK; 
                        affectedStones.push(targetStone); // 点滅対象に追加
                    } else {
                        if (i === 0) { 
                            fullScreenMessageElement.textContent += '(反転できる石がありませんでした)';
                        } else if (i === 1) { 
                             fullScreenMessageElement.textContent += '(反転できる石がもうありませんでした)';
                        }
                        break; 
                    }
                }
                renderBoard(); 
                updateGameInfo(); 

                // 反転した石に点滅アニメーションを適用
                affectedStones.forEach(stonePos => {
                    const stoneElement = boardElement.querySelector(`[data-row='${stonePos.row}'][data-col='${stonePos.col}'] .stone`);
                    if (stoneElement) {
                        stoneElement.classList.add('blink');
                        setTimeout(() => {
                            stoneElement.classList.remove('blink'); 
                        }, 6000); // 点滅時間を6秒に変更
                    }
                });

                // さらに2秒後にメッセージを消し、蒸気アニメーションを解除して、次のターンに進む
                setTimeout(() => {
                    fullScreenMessageElement.classList.remove('show', 'overload');
                    fullScreenMessageElement.textContent = ''; 
                    steamOverlayElement.classList.remove('active'); 
                    isSpecialEventActive = false; // イベント終了
                    switchPlayer(); // 次のターンへ
                }, 2000); 
            }, 2000); 
        }

        // 「しあらーの一服 SP」シーケンスを発動する関数 (1%確率)
        function triggerShiraraNoIppukuSPSequence() {
            if (gameOver) return;
            isSpecialEventActive = true; // イベント中フラグを立てる
            eventJustOccurred = true; // イベント発生フラグを立てる

            smokeOverlayElement.classList.add('active'); // 煙アニメーションを適用

            fullScreenMessageElement.classList.remove('sp', 'lucky', 'jamming', 'overload'); 
            fullScreenMessageElement.classList.add('shirara-sp'); 
            fullScreenMessageElement.textContent = 'しあらーの一服 SP';
            fullScreenMessageElement.classList.add('show');

            // 2秒後にメッセージを切り替え、効果を適用
            setTimeout(() => {
                fullScreenMessageElement.textContent = 'BVはすでに負けていた';

                // さらに2秒後にメッセージを消し、煙アニメーションを解除して、強制勝利
                setTimeout(() => {
                    fullScreenMessageElement.classList.remove('show', 'shirara-sp');
                    fullScreenMessageElement.textContent = ''; // メッセージクリア
                    smokeOverlayElement.classList.remove('active'); // 煙アニメーションを解除
                    isSpecialEventActive = false; // イベント終了
                    endGame(true); // プレイヤー勝利でゲーム終了 (紙吹雪も舞う)
                }, 2000); 
            }, 2000); 
        }


        // 手番を切り替える
        function switchPlayer() {
            if (gameOver) return;

            // `eventJustOccurred` がtrueの場合（直前にイベントが発生した場合）、
            // 今回のターンではイベント判定を行わないようにし、フラグをリセットする。
            if (eventJustOccurred) {
                eventJustOccurred = false; 
                // ここでcurrentPlayerを切り替える必要はない。
                // プレイヤーのイベント後に`switchPlayer`が呼ばれる場合、currentPlayerはBLACKのままなので、
                // そのままプレイヤーのターン処理に進む。
            } else {
                // 通常のターン切り替え
                currentPlayer = (currentPlayer === BLACK) ? WHITE : BLACK;
            }
            
            updateGameInfo();
            checkGameStatus(); 

            if (gameOver) return;

            // **イベントの発生判定は、`isSpecialEventActive` が false かつ `eventJustOccurred` が false の場合のみ行う**
            // **かつ、プレイヤー (BLACK) のターンでのみイベント発生抽選を行う**
            if (currentPlayer === BLACK && !isSpecialEventActive && !eventJustOccurred) { 
                const randomChance = Math.random();
                
                // SPイベント (それぞれ1% = 0.01)
                if (randomChance < 0.01) { // 1%の確率でHACKING SP (0.00-0.01)
                    triggerHackingSPSequence();
                } else if (randomChance < 0.02) { // 1%の確率でしあらーの一服 SP (0.01-0.02)
                    triggerShiraraNoIppukuSPSequence();
                }
                // 通常イベント (それぞれ5%) - SPイベントがトリガーされていない場合のみ判定
                // SPイベントの合計確率 0.02 を考慮して、その後の確率範囲で5%ずつ割り当てる
                // 通常HACKING, アゼミチの幸運, NICKELのジャミング, ma--kyunのオーバーロードのそれぞれの発生確率を0.05 (5%) に設定
                else if (randomChance < 0.02 + 0.05) { // 5%の確率で通常のHACKING (0.02-0.07)
                    triggerHackingSequence();
                } else if (randomChance < 0.02 + 0.05 + 0.05) { // 5%の確率でアゼミチの幸運 (0.07-0.12)
                    triggerAzemichiLuckySequence();
                } else if (randomChance < 0.02 + 0.05 + 0.05 + 0.05) { // 5%の確率でNICKELのジャミング (0.12-0.17)
                    triggerNickelJammingSequence();
                } else if (randomChance < 0.02 + 0.05 + 0.05 + 0.05 + 0.05) { // 5%の確率でma--kyunのオーバーロード (0.17-0.22)
                    triggerMaKyunOverloadSequence();
                }
                
                if (isSpecialEventActive) { // いずれかの特殊イベントがアクティブになった場合
                    return; // 通常フローには進まない
                }
            }

            // イベントが発生しなかった場合の通常フロー
            if (currentPlayer === WHITE) { // CPU (BrainVerse) のターン
                messageElement.textContent = CPU_NAME + 'の思考中...';
                renderBoard();

                const cpuValidMoves = getValidMoves(WHITE);
                if (cpuValidMoves.length === 0) {
                    messageElement.textContent = CPU_NAME + 'は置ける場所がないためパス！';
                    passCount++;
                    cpuFlipBlocked = false; // パスしたので効果を解除
                    setTimeout(switchPlayer, 500);
                } else {
                    setTimeout(cpuMove, 1000);
                }
            } else { // プレイヤー (W-MIND) のターン
                messageElement.textContent = PLAYER_NAME + 'の手番です。';
                renderBoard();
                highlightValidMoves();

                const playerValidMoves = getValidMoves(BLACK);
                if (playerValidMoves.length === 0) {
                     messageElement.textContent = PLAYER_NAME + 'は置ける場所がないためパス！';
                     passCount++;
                     setTimeout(switchPlayer, 500);
                }
            }
        }

        // CPUの手番ロジック (最もひっくり返せる手を選ぶ)
        function cpuMove() {
            if (gameOver) return;

            const validMoves = getValidMoves(WHITE);
            
            if (validMoves.length === 0) {
                cpuFlipBlocked = false; 
                switchPlayer();
                return;
            }

            let bestMove = null;
            let maxFlips = -1;

            validMoves.forEach(move => {
                const flipsCount = cpuFlipBlocked ? 0 : getFlips(move.row, move.col, WHITE).length;
                
                if (flipsCount > maxFlips) {
                    maxFlips = flipsCount;
                    bestMove = move;
                }
            });

            if (bestMove) {
                const actualFlips = cpuFlipBlocked ? [] : getFlips(bestMove.row, bestMove.col, WHITE);
                placeStoneAndFlip(bestMove.row, bestMove.col, WHITE, actualFlips);
            }
            
            cpuFlipBlocked = false; 
            switchPlayer();
        }

        // ゲームの状態をチェック (パス、ゲーム終了)
        function checkGameStatus() {
            if (gameOver) return;

            const blackCanMove = getValidMoves(BLACK).length > 0;
            const whiteCanMove = getValidMoves(WHITE).length > 0;

            if (passCount === 2 || (!blackCanMove && !whiteCanMove)) { 
                endGame();
                return;
            }

            let totalStones = 0;
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (board[r][c] !== EMPTY) {
                        totalStones++;
                    }
                }
            }
            if (totalStones === BOARD_SIZE * BOARD_SIZE) {
                endGame();
                return;
            }
        }

        // タイマー表示を更新する関数
        function updateTimerDisplay() {
            if (!startTime) return;
            const elapsedTime = Date.now() - startTime;
            const totalSeconds = Math.floor(elapsedTime / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            const formattedTime = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            timerDisplayElement.textContent = formattedTime;
        }

        // ゲーム終了処理
        function endGame(playerForcedWin = false) {
            if (gameOver) return;
            gameOver = true;
            
            clearInterval(timerInterval);
            const finalElapsedTime = timerDisplayElement.textContent;

            let blackStones = 0;
            let whiteStones = 0;
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (board[r][c] === BLACK) {
                        blackStones++;
                    } else if (board[r][c] === WHITE) {
                        whiteStones++;
                    }
                }
            }

            let resultText = '';
            // 強制勝利の場合、プレイヤーの石を多めに設定して勝利表示を確定させる (オプション)
            if (playerForcedWin) {
                blackStones = 99; // 強制勝利の場合、石の数を多く見せる
                whiteStones = 0;
                resultText = `SUCCESS!!<br>${PLAYER_NAME} WIN!!<br>(${blackStones} vs ${whiteStones})<br>時間: ${finalElapsedTime}`;
                messageElement.style.color = '#00ffff'; // HACKING SP と同様の色
                messageElement.style.borderColor = '#00ffff';
                messageElement.style.boxShadow = '0 0 30px rgba(0, 255, 255, 0.8)';
                showConfetti();
            }
            else if (blackStones > whiteStones) {
                resultText = `WIN!!<br>(${blackStones} vs ${whiteStones})<br>時間: ${finalElapsedTime}`;
                messageElement.style.color = '#76ff03';
                messageElement.style.borderColor = '#76ff03';
                messageElement.style.boxShadow = '0 0 30px rgba(118, 255, 3, 0.8)';
                showConfetti();
            } else if (whiteStones > blackStones) {
                resultText = `LOSE...<br>(${whiteStones} vs ${blackStones})<br>時間: ${finalElapsedTime}`;
                messageElement.style.color = '#ff1744';
                messageElement.style.borderColor = '#ff1744';
                messageElement.style.boxShadow = '0 0 30px rgba(255, 23, 68, 0.8)';
            } else {
                resultText = `DRAW<br>(${blackStones} vs ${whiteStones})<br>時間: ${finalElapsedTime}`;
                messageElement.style.color = '#80deea';
                messageElement.style.borderColor = '#80deea';
                messageElement.style.boxShadow = '0 0 30px rgba(0, 220, 255, 0.5)';
            }
            
            messageElement.innerHTML = resultText;
            messageElement.classList.add('final-result');
            renderBoard();
        }

        // あるマス (r, c) に player の石を置いたときにひっくり返せる石のリストを取得
        function getFlips(r, c, player, boardState = board) {
            if (boardState[r][c] !== EMPTY) return [];

            const opponent = (player === BLACK) ? WHITE : BLACK;
            let flippedStones = [];

            const directions = [
                [-1, -1], [-1, 0], [-1, 1],
                [ 0, -1],          [ 0, 1],
                [ 1, -1], [ 1, 0], [ 1, 1]
            ];

            for (const [dr, dc] of directions) {
                let currentFlipped = [];
                let newR = r + dr;
                let newC = c + dc;

                while (newR >= 0 && newR < BOARD_SIZE && newC >= 0 && newC < BOARD_SIZE && boardState[newR][newC] === opponent) {
                    currentFlipped.push({ row: newR, col: newC });
                    newR += dr;
                    newC += dc;
                }

                if (newR >= 0 && newR < BOARD_SIZE && newC >= 0 && newC < BOARD_SIZE && boardState[newR][newC] === player && currentFlipped.length > 0) {
                    flippedStones = flippedStones.concat(currentFlipped);
                }
            }
            return flippedStones;
        }

        // 現在の手番 (player) が置ける全ての有効なマスを取得
        function getValidMoves(player) {
            let validMoves = [];
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (board[r][c] === EMPTY) {
                        const flips = getFlips(r, c, player);
                        if (flips.length > 0) {
                            validMoves.push({ row: r, col: c }); 
                        }
                    }
                }
            }
            return validMoves;
        }

        // 紙吹雪を降らせる関数
        function showConfetti() {
            confettiContainer.innerHTML = '';
            const numberOfConfetti = 100;

            for (let i = 0; i < numberOfConfetti; i++) {
                const confetti = document.createElement('div');
                confetti.classList.add('confetti');
                confetti.style.left = Math.random() * 100 + 'vw';
                confetti.style.animationDelay = Math.random() * 5 + 's';
                confetti.style.backgroundColor = `hsl(${Math.random() * 360}, 100%, 70%)`;
                confetti.style.width = Math.random() * 8 + 5 + 'px';
                confetti.style.height = confetti.style.width;
                confetti.style.animationDuration = (Math.random() * 3 + 4) + 's';
                confetti.style.animationIterationCount = 'infinite';
                confettiContainer.appendChild(confetti);
            }
        }

        // 紙吹雪を非表示にする関数
        function hideConfetti() {
            confettiContainer.innerHTML = '';
        }

        // リセットボタンのイベントリスナー
        resetButton.addEventListener('click', initializeGame);

        // 初期ロード時にゲームを開始
        initializeGame();
    </script>
</body>
</html>